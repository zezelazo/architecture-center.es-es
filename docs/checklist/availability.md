---
title: Lista de comprobación de disponibilidad
description: Lista de comprobación que ofrece una guía para las inquietudes sobre disponibilidad durante el diseño.
author: dragon119
ms.date: 01/10/2018
ms.custom: checklist
ms.openlocfilehash: 324d8200d822eb1a7dce95ba4b2a7f29b00fb291
ms.sourcegitcommit: 441185360db49cfb3cf39527b68f318d17d4cb3d
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 01/19/2018
---
# <a name="availability-checklist"></a>Lista de comprobación de disponibilidad

La disponibilidad es la proporción de tiempo que un sistema es funcional y funciona, y es uno de los [pilares de la calidad del software](../guide/pillars.md). Use esta lista de comprobación para revisar la arquitectura de la aplicación desde una perspectiva de disponibilidad. 

## <a name="application-design"></a>Diseño de aplicación

**Evitar los puntos únicos de error.** Todos los componentes, servicios, recursos e instancias de procesos deben implementarse como varias instancias para impedir que un único punto de error afecte a la disponibilidad. Esto incluye mecanismos de autenticación. Diseñe la aplicación para que se configure para usar varias instancias y para detectar errores automáticamente y redirigir las solicitudes a instancias sin errores donde la plataforma no lo hace automáticamente.

**Descomponga las cargas de trabajo por objetivo de nivel de servicio.** Si un servicio se compone de cargas de trabajo críticas y menos críticas, adminístrelas de manera diferente y especifique las características de servicio y el número de instancias para satisfacer sus requisitos de disponibilidad.

**Minimizar y comprender las dependencias de servicio.** Minimice el número de servicios diferentes que se usan siempre que sea posible y asegúrese de que comprende todas las dependencias de características y servicios que existen en el sistema. Esto incluye la naturaleza de estas dependencias y el impacto del error o la reducción del rendimiento de cada una de ellas en la aplicación general. Consulte [Definición de los requisitos de resistencia](../resiliency/index.md#defining-your-resiliency-requirements).

**Diseñar las tareas y los mensajes para que sean idempotentes siempre que sea posible**. Una operación es idempotente si se puede repetir varias veces y generar el mismo resultado. La idempotencia puede garantizar que las solicitudes duplicadas no provocan problemas. Los consumidores de mensajes y las operaciones que llevan a cabo deben ser idempotentes para que la repetición de una operación ejecutada anteriormente no represente los resultados no válidos. Esto puede significar la detección de mensajes duplicados o garantizar la coherencia mediante un enfoque optimista para tratar los conflictos.

**Usar un agente de mensajes que implementa alta disponibilidad para las transacciones críticas.** Muchas aplicaciones en la nube usan mensajes para iniciar tareas que se realizan de forma asincrónica. Para garantizar la entrega de mensajes, el sistema de mensajería debe proporcionar una alta disponibilidad. La mensajería de [Azure Service Bus](/azure/service-bus-messaging) implementa semántica *al menos una vez*. Esto significa que un mensaje enviado a una cola no se perderá, aunque en determinadas circunstancias se puedan entregar copias duplicadas. Si el procesamiento de mensajes es idempotente (vea el elemento anterior), la entrega repetida no debería ser un problema.

**Diseñar aplicaciones para degradarlas de forma correcta.** La carga en una aplicación puede superar la capacidad de una o más partes y hacer que se reduzca la disponibilidad y se produzcan errores en las conexiones. El ajuste de escala puede ayudar a aliviar esto, pero puede tener un límite determinado por otros factores, como el costo o la disponibilidad de recursos. Si una aplicación alcanza un límite de recursos, debe realizar las acciones adecuadas para minimizar el impacto para el usuario. Por ejemplo, en un sistema de comercio electrónico, si el subsistema de procesamiento de pedidos está bajo presión, o no funciona en absoluto, se puede deshabilitar temporalmente y permitir que continúen otras funciones, como la exploración del catálogo de productos. Podría ser adecuado posponer las solicitudes a un subsistema con errores y permitir, por ejemplo, que los clientes envíen pedidos pero guardarlos para procesarlos más adelante, cuando el subsistema de pedidos vuelva a estar disponible.

**Administrar correctamente los eventos rápidos de ráfaga.** La mayoría de las aplicaciones debe administrar cargas de trabajo que varían con el tiempo. El ajuste de escala automático puede ayudar a controlar la carga, pero se puede tardar algún tiempo en que las instancias adicionales entren en línea y controlen las solicitudes. Impida que las ráfagas repentinas e inesperadas de actividad sobrecarguen la aplicación: diséñela para poner en cola las solicitudes a los servicios que usa y para degradarlas correctamente cuando las colas estén cercanas a la capacidad completa. Asegúrese de que hay suficiente capacidad y rendimiento disponibles en condiciones sin ráfaga para descargar las colas y controlar las solicitudes pendientes. Para obtener más información, vea el [modelo de nivelación de carga basado en cola](https://msdn.microsoft.com/library/dn589783.aspx).

## <a name="deployment-and-maintenance"></a>Implementación y mantenimiento

**Implemente varias instancias de servicios.** Si la aplicación depende de una única instancia de un servicio, crea un único punto de error. El aprovisionamiento de varias instancias mejora tanto la resistencia como la escalabilidad. Para [Azure App Service](/azure/app-service/app-service-value-prop-what-is/), seleccione un [Plan de App Service](/azure/app-service/azure-web-sites-web-hosting-plans-in-depth-overview/) que ofrezca varias instancias. Para Azure Cloud Services, configure cada uno de los roles para utilizar [varias instancias](/azure/cloud-services/cloud-services-choose-me/#scaling-and-management). Para [Azure Virtual Machines](/azure/virtual-machines/virtual-machines-windows-about/?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json), asegúrese de que la arquitectura de máquina virtual incluya más de una máquina virtual y que cada una de ellas se incluya en un [conjunto de disponibilidad][availability-sets].

**Considere la posibilidad de implementar la aplicación en varias regiones.** Si su aplicación se implementa en una sola región, en el caso excepcional de que toda la región no esté disponible, la aplicación tampoco estará disponible. Esto puede ser inaceptable bajo los términos del Acuerdo de Nivel de Servicio de la aplicación. Si ese fuera el caso, considere la posibilidad de implementar la aplicación en varias regiones.

**Automatizar y probar las tareas de implementación y mantenimiento.** Las aplicaciones distribuidas constan de varias partes que deben funcionar en conjunto. La implementación debe automatizarse mediante mecanismos probados y comprobados, como scripts. Estos pueden actualizar y validar la configuración y automatizar el proceso de implementación. Use [plantillas de Azure Resource Manager](/azure/azure-resource-manager/resource-group-authoring-templates) para aprovisionar los recursos de Azure. Además, use técnicas automatizadas para realizar actualizaciones de la aplicación. Es fundamental probar todos estos procesos por completo para asegurarse de que los errores no provocan tiempo de inactividad adicional. Todas las herramientas de implementación deben tener restricciones de seguridad adecuados para proteger la aplicación implementada; defina y aplique directivas de implementación con cuidado y minimice la necesidad de la intervención humana.

**Usar características de ensayo y producción de la plataforma.**. Por ejemplo, Azure App Service admite [espacios de implementación](/azure/app-service/web-sites-staged-publishing), que puede usar para realizar el ensayo de una implementación antes de pasarla a producción. Azure Service Fabric admite [actualizaciones graduales](/azure/service-fabric/service-fabric-application-upgrade) a servicios de aplicación.

**Colocar las máquinas virtuales (VM) en un conjunto de disponibilidad.** Para maximizar la disponibilidad, cree varias instancias de cada rol de máquina virtual y coloque estas instancias en el mismo conjunto de disponibilidad. Si tiene varias máquinas virtuales que atienden diferentes roles, por ejemplo, diferentes capas de aplicación, cree un conjunto de disponibilidad para cada uno. Por ejemplo, cree un conjunto de disponibilidad para la capa web y otro para la capa de datos.

## <a name="data-management"></a>Administración de datos

**Replicación geográfica de los datos en Azure Storage**. Los datos en Azure Storage se replican automáticamente dentro de un centro de datos. Para aún mayor disponibilidad, use el almacenamiento con redundancia geográfica con acceso de lectura (-RAGRS), que replica los datos en una región secundaria y proporciona acceso de solo lectura a los datos en la ubicación secundaria. Los datos son duraderos aun en el caso de una interrupción total o un desastre en la región. Para más información, consulte [Replicación de Azure Storage](/azure/storage/storage-redundancy).

**Replicación geográfica de bases de datos**. Azure SQL Database y Cosmos DB admiten replicación geográfica, lo que permite configurar réplicas de bases de datos secundarias en otras regiones. Las bases de datos secundarias están disponibles para la consulta y la conmutación por error en caso de una interrupción del centro de datos o de imposibilidad para conectarse a la base de datos principal. Para más información, consulte [Grupos de conmutación por error y replicación geográfica activa](/azure/sql-database/sql-database-geo-replication-overview) (SQL Database) y [Cómo se distribuyen datos globalmente con Azure Cosmos DB](/azure/cosmos-db/distribute-data-globally).

**Usar simultaneidad optimista y coherencia eventual**. Las transacciones que bloquean el acceso a recursos a través del bloqueo (concurrencia pesimista) pueden producir un bajo rendimiento y reducir considerablemente la disponibilidad. Estos problemas pueden ser especialmente importantes en sistemas distribuidos. En muchos casos, las técnicas y un diseño cuidadoso como la creación de particiones pueden minimizar las posibilidades de que se produzcan actualizaciones que generan conflictos. Cuando los datos se replican o se leen desde un almacén actualizado por separado, los datos solo serán coherentes en última instancia. Pero las ventajas superan normalmente con creces el impacto sobre la disponibilidad de uso de las transacciones para garantizar la coherencia inmediata.

**Usar copias de seguridad periódicas y restauración a un momento dado**. Realice copias de seguridad de datos regulares y automáticas que no se conserven en otra parte y compruebe que puede restaurar con confiabilidad tanto los datos como la propia aplicación en el que caso de que produzca un error. Asegúrese de que las copias de seguridad cumplen el objetivo de punto de recuperación (RPO). La replicación de datos no es una característica de copia de seguridad, porque los errores humanos o las operaciones malintencionadas pueden dañar los datos en todas las réplicas. El proceso de copia de seguridad debe ser seguro para proteger los datos en tránsito y en almacenamiento. Las bases de datos o las partes de un almacén de datos se pueden recuperar normalmente para un momento anterior en el tiempo mediante registros de transacciones. Para más información, consulte [Recuperación de datos dañados o de eliminaciones accidentales](../resiliency/recovery-data-corruption.md).

## <a name="errors-and-failures"></a>Errores

**Configurar tiempos de espera de solicitud.** Puede que los servicios y recursos dejen de estar disponibles, provocando errores en las solicitudes. Asegúrese de que los tiempos de espera que aplique sean adecuados para cada servicio o recurso y para el cliente que tiene acceso a ellos. En algunos casos, podría permitir un tiempo de espera más largo para una instancia determinada de un cliente, según el contexto y otras acciones que realice el cliente. Tiempos de espera muy breves pueden provocar un número excesivo de operaciones de reintento para servicios y recursos que tienen una latencia considerable. Tiempos de espera muy largos pueden provocar bloqueo si un gran número de solicitudes están en cola, a la espera de que responda un servicio o recurso.

**Reintentar las operaciones con errores causadas por errores transitorios.** Diseñe una estrategia de reintento para acceder a todos los servicios y recursos donde no admiten de manera inherente el reintento de conexión automática. Use una estrategia que incluya un retraso creciente entre reintentos conforme aumenta el número de errores para evitar la sobrecarga del recurso y para permitirle que recupere y controle de forma correcta las solicitudes en cola. Los reintentos continuos con retrasos muy breves suelen agravar el problema. Para más información, consulte [Retry guidance for specific services](../best-practices/retry-service-specific.md) (Guía de reintentos para servicios específicos).

**Implementar Circuit Breaker para evitar errores en cascada.** Puede haber situaciones en las que errores transitorios o de otro tipo, con una gravedad que abarca desde una pérdida parcial de la conectividad hasta el error completo de un servicio, tarden mucho más tiempo del esperado en volver a su estado normal. Si un servicio está muy ocupado, el error en una parte del sistema puede provocar errores en cascada y hacer que se bloqueen muchas operaciones mientras se retienen en recursos críticos del sistema como la memoria, los subprocesos y las conexiones de base de datos. En lugar de reintentar continuamente una operación que es improbable que tenga éxito, la aplicación debería aceptar rápidamente que la operación ha generado error y tratar correctamente este error. Use el patrón Circuit Breaker para rechazar solicitudes para operaciones específicas durante períodos definidos. Para más información, consulte [Circuit Breaker Pattern](../patterns/circuit-breaker.md) (Patrón Circuit Breaker).

**Crear o revertir a varios componentes.** Siempre que sea posible, diseñe aplicaciones para usar varias instancias sin afectar a las operaciones y las conexiones existentes. Con el fin de maximizar la disponibilidad, use varias instancias y distribuya las solicitudes entre ellas, y detecte y evite el envío de solicitudes a instancias con error.

**Revertir a un flujo de trabajo o servicio diferente.** Por ejemplo, si se produce un error de escritura en SQL Database, almacene temporalmente los datos en el almacenamiento de blobs o en Redis Cache. Proporcione una manera de reproducir las escrituras en SQL Database cuando el servicio se vuelva disponible. En algunos casos, una operación con error puede tener una acción alternativa que permite que la aplicación continúe trabajando incluso cuando un componente o un servicio produce un error. Si es posible, detecte errores y redirija solicitudes a otros servicios que puedan ofrecer una funcionalidad alternativa adecuada, o a instancias de funciones de copia de seguridad o reducidas que puedan mantener operaciones principales mientras el servicio principal está sin conexión.

## <a name="monitoring-and-disaster-recovery"></a>Supervisión y recuperación ante desastres

**Proporcionar instrumentación enriquecida para errores probables y eventos de error** para notificar la situación al personal de operaciones. Para los errores que son probables pero que no se han producido todavía, ofrezca datos suficientes para habilitar al personal de operaciones para determinar la causa, mitigar la situación y garantizar que el sistema sigue disponible. Para los errores que ya se han producido, la aplicación debe devolver un mensaje de error adecuado al usuario pero intentará continuar ejecutándose, aunque con funcionalidad reducida. En todos los casos, el sistema de supervisión debe capturar información completa para permitir que el personal de operaciones lleve a cabo una recuperación rápida y, en caso necesario, para que los diseñadores y desarrolladores modifiquen el sistema a fin de evitar que la situación se produzca de nuevo.

**Supervisar el estado del sistema mediante la implementación de funciones de comprobación.** El mantenimiento y el rendimiento de una aplicación pueden reducirse con el tiempo sin que sea apreciable hasta que se produce un error. Implemente sondeos o funciones de comprobación que se ejecuten con regularidad desde fuera de la aplicación. Estas comprobaciones pueden ser tan simples como la medición del tiempo de respuesta para la aplicación en su conjunto, para las partes individuales de la aplicación, para los servicios individuales que usa la aplicación o para los componentes individuales. Las funciones de comprobación pueden ejecutar procesos para garantizar que producen resultados válidos, para medir la latencia y comprobar la disponibilidad, y para extraer la información del sistema.

**Probar con regularidad todos los sistemas de reserva y de conmutación por error.** Los cambios realizados a los sistemas y las operaciones pueden afectar a las funciones de reserva y de conmutación por error, pero es posible que no se detecte el impacto hasta que el sistema principal genere un error o se sobrecargue. Las pruebas anticipadas son necesarias para evitar problemas en directo en tiempo de ejecución.

**Probar los sistemas de supervisión.** Los sistemas automatizados de conmutación por error y de reserva, así como la visualización manual del rendimiento y el mantenimiento del sistema mediante el uso de paneles, dependen del funcionamiento correcto de la supervisión y la instrumentación. Si estos elementos generan un error, pierden información fundamental o informan de datos imprecisos, es posible que un operador no se dé cuenta de que el sistema está en mal estado o de que tiene errores.

**Realizar un seguimiento del progreso de los flujos de trabajo de larga ejecución y volver a intentarlo en caso de error.** Los flujos de trabajo de larga ejecución suelen constar de varios pasos. Asegúrese de que cada paso sea independiente y de que se pueda volver a intentar para minimizar la posibilidad de que se tenga que revertir todo el flujo de trabajo o de que se tengan que ejecutar varias transacciones de compensación. Supervise y administre el progreso de los flujos de trabajo de larga ejecución implementando un patrón como [el supervisor del agente del programador](../patterns/scheduler-agent-supervisor.md).

**Planear la recuperación ante desastres.** Cree un plan aceptado y probado para la recuperación de cualquier tipo de error que pueda afectar a la disponibilidad del sistema. Elija una arquitectura de recuperación ante desastres multisitio para las aplicaciones críticas. Designe un propietario específico del plan de recuperación ante desastres, incluida la automatización y las pruebas. Asegúrese de que el plan esté bien documentado y automatice el proceso tanto como sea posible. Establezca una estrategia de copia de seguridad para todos los datos transaccionales y de referencia, y pruebe la restauración de estas copias de seguridad con regularidad. Enseñe al personal de operaciones a ejecutar el plan y realizar simulaciones de desastres periódicas para validar y mejorar el plan.

<!-- links -->
[availability-sets]:/azure/virtual-machines/virtual-machines-windows-manage-availability/
