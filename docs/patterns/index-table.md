---
title: Patrón Index Table
titleSuffix: Cloud Design Patterns
description: Crea índices en los campos de los almacenes de datos a los que suelen hacer referencia las consultas.
keywords: Patrón de diseño
author: dragon119
ms.date: 06/23/2017
ms.custom: seodec18
ms.openlocfilehash: 206d064b80dd980c9b5fdfb1233ff2dd8baafbaf
ms.sourcegitcommit: 680c9cef945dff6fee5e66b38e24f07804510fa9
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 01/04/2019
ms.locfileid: "54011008"
---
# <a name="index-table-pattern"></a><span data-ttu-id="722c3-104">Patrón Index Table</span><span class="sxs-lookup"><span data-stu-id="722c3-104">Index Table pattern</span></span>

[!INCLUDE [header](../_includes/header.md)]

<span data-ttu-id="722c3-105">Crea índices en los campos de los almacenes de datos a los que suelen hacer referencia las consultas.</span><span class="sxs-lookup"><span data-stu-id="722c3-105">Create indexes over the fields in data stores that are frequently referenced by queries.</span></span> <span data-ttu-id="722c3-106">Este patrón puede mejorar el rendimiento de las consultas permitiendo a las aplicaciones localizar más rápidamente los datos a recuperar desde un almacén de datos.</span><span class="sxs-lookup"><span data-stu-id="722c3-106">This pattern can improve query performance by allowing applications to more quickly locate the data to retrieve from a data store.</span></span>

## <a name="context-and-problem"></a><span data-ttu-id="722c3-107">Contexto y problema</span><span class="sxs-lookup"><span data-stu-id="722c3-107">Context and problem</span></span>

<span data-ttu-id="722c3-108">Muchos almacenes de datos organizan los datos de una colección de entidades mediante la clave principal.</span><span class="sxs-lookup"><span data-stu-id="722c3-108">Many data stores organize the data for a collection of entities using the primary key.</span></span> <span data-ttu-id="722c3-109">Una aplicación puede usar esta clave para buscar y recuperar datos.</span><span class="sxs-lookup"><span data-stu-id="722c3-109">An application can use this key to locate and retrieve data.</span></span> <span data-ttu-id="722c3-110">La ilustración muestra un ejemplo de un almacén de datos que contiene información del cliente.</span><span class="sxs-lookup"><span data-stu-id="722c3-110">The figure shows an example of a data store holding customer information.</span></span> <span data-ttu-id="722c3-111">La clave principal es el identificador del cliente.</span><span class="sxs-lookup"><span data-stu-id="722c3-111">The primary key is the Customer ID.</span></span> <span data-ttu-id="722c3-112">La ilustración muestra la información del cliente organizada por la clave principal (identificador del cliente).</span><span class="sxs-lookup"><span data-stu-id="722c3-112">The figure shows customer information organized by the primary key (Customer ID).</span></span>

![Figura 1: Información del cliente organizada por la clave principal (identificador del cliente)](./_images/index-table-figure-1.png)

<span data-ttu-id="722c3-114">Aunque la clave principal es útil para consultas que capturan datos basados en el valor de esta clave, es posible que una aplicación no pueda usarla si necesita recuperar datos basados en algún otro campo.</span><span class="sxs-lookup"><span data-stu-id="722c3-114">While the primary key is valuable for queries that fetch data based on the value of this key, an application might not be able to use the primary key if it needs to retrieve data based on some other field.</span></span> <span data-ttu-id="722c3-115">En el ejemplo de los clientes, una aplicación no puede usar la clave principal de identificador del cliente para recuperar clientes si consulta los datos haciendo referencia únicamente al valor de algún otro atributo, como la ciudad en la que está ubicado el cliente.</span><span class="sxs-lookup"><span data-stu-id="722c3-115">In the customers example, an application can't use the Customer ID primary key to retrieve customers if it queries data solely by referencing the value of some other attribute, such as the town in which the customer is located.</span></span> <span data-ttu-id="722c3-116">Para realizar una consulta como esta, puede que la aplicación tenga que capturar y examinar todos los registros de los clientes, lo cual podría ser un proceso lento.</span><span class="sxs-lookup"><span data-stu-id="722c3-116">To perform a query such as this, the application might have to fetch and examine every customer record, which could be a slow process.</span></span>

<span data-ttu-id="722c3-117">Muchos sistemas de administración de bases de datos relacionales admiten índices secundarios.</span><span class="sxs-lookup"><span data-stu-id="722c3-117">Many relational database management systems support secondary indexes.</span></span> <span data-ttu-id="722c3-118">Un índice secundario es una estructura de datos independiente que se organiza por uno o varios campos clave no principales (secundarios), y que indica dónde se almacenan los datos de cada valor indexado.</span><span class="sxs-lookup"><span data-stu-id="722c3-118">A secondary index is a separate data structure that's organized by one or more nonprimary (secondary) key fields, and it indicates where the data for each indexed value is stored.</span></span> <span data-ttu-id="722c3-119">Normalmente, los elementos de un índice secundario se ordenan por el valor de las claves secundarias lo cual permite unas búsquedas rápidas de datos.</span><span class="sxs-lookup"><span data-stu-id="722c3-119">The items in a secondary index are typically sorted by the value of the secondary keys to enable fast lookup of data.</span></span> <span data-ttu-id="722c3-120">Normalmente, el sistema de administración de bases de datos es el encargado de mantener automáticamente estos índices.</span><span class="sxs-lookup"><span data-stu-id="722c3-120">These indexes are usually maintained automatically by the database management system.</span></span>

<span data-ttu-id="722c3-121">Puede crear tantos índices secundarios como sea necesario para admitir las distintas consultas que realiza la aplicación.</span><span class="sxs-lookup"><span data-stu-id="722c3-121">You can create as many secondary indexes as you need to support the different queries that your application performs.</span></span> <span data-ttu-id="722c3-122">Por ejemplo, en una tabla de clientes de una base de datos relacional en la que el identificador de cliente es la clave principal, es útil agregar un índice secundario con el campo de ciudad si la aplicación busca con frecuencia clientes por la ciudad en la que residen.</span><span class="sxs-lookup"><span data-stu-id="722c3-122">For example, in a Customers table in a relational database where the Customer ID is the primary key, it's beneficial to add a secondary index over the town field if the application frequently looks up customers by the town where they reside.</span></span>

<span data-ttu-id="722c3-123">Sin embargo, aunque los índices secundarios son habituales en los sistemas relacionales, la mayoría de los almacenes de datos NoSQL utilizados por aplicaciones en la nube no proporcionan ninguna característica equivalente.</span><span class="sxs-lookup"><span data-stu-id="722c3-123">However, although secondary indexes are common in relational systems, most NoSQL data stores used by cloud applications don't provide an equivalent feature.</span></span>

## <a name="solution"></a><span data-ttu-id="722c3-124">Solución</span><span class="sxs-lookup"><span data-stu-id="722c3-124">Solution</span></span>

<span data-ttu-id="722c3-125">Si el almacén de datos no admite índices secundarios, puede emularlos manualmente mediante la creación de sus propias tablas de índice.</span><span class="sxs-lookup"><span data-stu-id="722c3-125">If the data store doesn't support secondary indexes, you can emulate them manually by creating your own index tables.</span></span> <span data-ttu-id="722c3-126">Una tabla de índice organiza los datos mediante una clave especificada.</span><span class="sxs-lookup"><span data-stu-id="722c3-126">An index table organizes the data by a specified key.</span></span> <span data-ttu-id="722c3-127">Normalmente se usan tres estrategias para estructurar una tabla de índice, dependiendo del número de índices secundarios que sean necesarios y la naturaleza de las consultas que realiza una aplicación.</span><span class="sxs-lookup"><span data-stu-id="722c3-127">Three strategies are commonly used for structuring an index table, depending on the number of secondary indexes that are required and the nature of the queries that an application performs.</span></span>

<span data-ttu-id="722c3-128">La primera estrategia consiste en duplicar los datos de cada tabla de índice pero organizándola por claves diferentes (desnormalización completa).</span><span class="sxs-lookup"><span data-stu-id="722c3-128">The first strategy is to duplicate the data in each index table but organize it by different keys (complete denormalization).</span></span> <span data-ttu-id="722c3-129">En la ilustración siguiente se muestran las tablas de índice que organizan la misma información del cliente por ciudad y apellido.</span><span class="sxs-lookup"><span data-stu-id="722c3-129">The next figure shows index tables that organize the same customer information by Town and LastName.</span></span>

![Figura 2: Los datos se duplican en cada tabla de índice](./_images/index-table-figure-2.png)

<span data-ttu-id="722c3-131">Esta estrategia es adecuada si los datos son relativamente estáticos en comparación con el número de veces que se consulta mediante cada clave.</span><span class="sxs-lookup"><span data-stu-id="722c3-131">This strategy is appropriate if the data is relatively static compared to the number of times it's queried using each key.</span></span> <span data-ttu-id="722c3-132">Si los datos son más dinámicos, la sobrecarga de procesamiento que supone mantener cada tabla de índice resulta demasiado grande para que este enfoque sea útil.</span><span class="sxs-lookup"><span data-stu-id="722c3-132">If the data is more dynamic, the processing overhead of maintaining each index table becomes too large for this approach to be useful.</span></span> <span data-ttu-id="722c3-133">Además, si el volumen de datos es muy grande, la cantidad de espacio necesario para almacenar los datos duplicados es significativa.</span><span class="sxs-lookup"><span data-stu-id="722c3-133">Also, if the volume of data is very large, the amount of space required to store the duplicate data is significant.</span></span>

<span data-ttu-id="722c3-134">La segunda estrategia consiste en crear tablas de índice normalizadas organizadas por diferentes claves y hacer referencia a los datos originales mediante la clave principal en lugar de duplicarla, como se indica en la siguiente ilustración.</span><span class="sxs-lookup"><span data-stu-id="722c3-134">The second strategy is to create normalized index tables organized by different keys and reference the original data by using the primary key rather than duplicating it, as shown in the following figure.</span></span> <span data-ttu-id="722c3-135">Los datos originales se denominan tabla de hechos.</span><span class="sxs-lookup"><span data-stu-id="722c3-135">The original data is called a fact table.</span></span>

![Figura 3: Se hace referencia a los datos por cada tabla de índice](./_images/index-table-figure-3.png)

<span data-ttu-id="722c3-137">Esta técnica ahorra espacio y reduce la sobrecarga que supone mantener los datos duplicados.</span><span class="sxs-lookup"><span data-stu-id="722c3-137">This technique saves space and reduces the overhead of maintaining duplicate data.</span></span> <span data-ttu-id="722c3-138">La desventaja es que una aplicación tiene que realizar dos operaciones de búsqueda para buscar datos mediante una clave secundaria.</span><span class="sxs-lookup"><span data-stu-id="722c3-138">The disadvantage is that an application has to perform two lookup operations to find data using a secondary key.</span></span> <span data-ttu-id="722c3-139">Debe buscar la clave principal de los datos de la tabla de índice y, después, usar la clave principal para buscar los datos en la tabla de hechos.</span><span class="sxs-lookup"><span data-stu-id="722c3-139">It has to find the primary key for the data in the index table, and then use the primary key to look up the data in the fact table.</span></span>

<span data-ttu-id="722c3-140">La tercera estrategia consiste en crear tablas de índices parcialmente normalizadas y organizadas por claves diferentes que duplican los campos que se recuperan con frecuencia.</span><span class="sxs-lookup"><span data-stu-id="722c3-140">The third strategy is to create partially normalized index tables organized by different keys that duplicate frequently retrieved fields.</span></span> <span data-ttu-id="722c3-141">Haga referencia a la tabla de hechos para acceder a los campos a los que se accede con menos frecuencia.</span><span class="sxs-lookup"><span data-stu-id="722c3-141">Reference the fact table to access less frequently accessed fields.</span></span> <span data-ttu-id="722c3-142">La siguiente ilustración muestra cómo se duplican los datos a los que se accede habitualmente en cada tabla de índice.</span><span class="sxs-lookup"><span data-stu-id="722c3-142">The next figure shows how commonly accessed data is duplicated in each index table.</span></span>

![Figura 4: Duplicación de los datos a los que se accede habitualmente en cada tabla de índice](./_images/index-table-figure-4.png)

<span data-ttu-id="722c3-144">Con esta estrategia, puede lograr un equilibrio entre los dos primeros enfoques.</span><span class="sxs-lookup"><span data-stu-id="722c3-144">With this strategy, you can strike a balance between the first two approaches.</span></span> <span data-ttu-id="722c3-145">Los datos de las consultas habituales se pueden recuperar rápidamente mediante una sola búsqueda, mientras que la sobrecarga de espacio y de mantenimiento no es tan significativa como la que se produce al duplicar todo el conjunto de datos.</span><span class="sxs-lookup"><span data-stu-id="722c3-145">The data for common queries can be retrieved quickly by using a single lookup, while the space and maintenance overhead isn't as significant as duplicating the entire data set.</span></span>

<span data-ttu-id="722c3-146">Si una aplicación realiza consultas frecuentes de datos mediante la especificación de una combinación de valores (por ejemplo, "Buscar todos los clientes que viven en Redmond y que tienen el apellido Smith"), puede implementar las claves para los elementos de la tabla de índice como una concatenación del atributo Town y del atributo LastName.</span><span class="sxs-lookup"><span data-stu-id="722c3-146">If an application frequently queries data by specifying a combination of values (for example, “Find all customers that live in Redmond and that have a last name of Smith”), you could implement the keys to the items in the index table as a concatenation of the Town attribute and the LastName attribute.</span></span> <span data-ttu-id="722c3-147">La ilustración siguiente muestra una tabla de índice basada en claves compuestas.</span><span class="sxs-lookup"><span data-stu-id="722c3-147">The next figure shows an index table based on composite keys.</span></span> <span data-ttu-id="722c3-148">Las claves se ordenan por ciudad, y luego por apellidos en el caso de aquellos registros que tienen el mismo valor para la ciudad.</span><span class="sxs-lookup"><span data-stu-id="722c3-148">The keys are sorted by Town, and then by LastName for records that have the same value for Town.</span></span>

![Ilustración 5: Una tabla de índice basada en claves compuestas](./_images/index-table-figure-5.png)

<span data-ttu-id="722c3-150">Las tablas de índice pueden acelerar las operaciones de consulta en datos con particiones y son especialmente útiles en los casos en los que a la clave de partición se le aplica un algoritmo hash.</span><span class="sxs-lookup"><span data-stu-id="722c3-150">Index tables can speed up query operations over sharded data, and are especially useful where the shard key is hashed.</span></span> <span data-ttu-id="722c3-151">En la ilustración siguiente se muestra un ejemplo en el que la clave de partición es un hash del identificador de cliente.</span><span class="sxs-lookup"><span data-stu-id="722c3-151">The next figure shows an example where the shard key is a hash of the Customer ID.</span></span> <span data-ttu-id="722c3-152">La tabla de índice puede organizar los datos por el valor al que no se ha aplicado el algoritmo hash (Town y LastName) y proporcionar la clave de partición con hash como los datos de búsqueda.</span><span class="sxs-lookup"><span data-stu-id="722c3-152">The index table can organize data by the nonhashed value (Town and LastName), and provide the hashed shard key as the lookup data.</span></span> <span data-ttu-id="722c3-153">Esto puede ahorrar a la aplicación el tener que calcular repetidamente las claves hash (una operación costosa) si necesita recuperar los datos que se encuentran dentro de un intervalo, o si necesita capturar datos para la clave sin algoritmo hash.</span><span class="sxs-lookup"><span data-stu-id="722c3-153">This can save the application from repeatedly calculating hash keys (an expensive operation) if it needs to retrieve data that falls within a range, or it needs to fetch data in order of the nonhashed key.</span></span> <span data-ttu-id="722c3-154">Por ejemplo, una consulta como "Buscar todos los clientes que viven en Redmond" se puede resolver rápidamente localizando los elementos coincidentes en la tabla de índice, en la que están todos almacenados en un bloque contiguo.</span><span class="sxs-lookup"><span data-stu-id="722c3-154">For example, a query such as “Find all customers that live in Redmond” can be quickly resolved by locating the matching items in the index table, where they're all stored in a contiguous block.</span></span> <span data-ttu-id="722c3-155">Después, siga las referencias a los datos del cliente mediante las claves de partición almacenadas en la tabla de índice.</span><span class="sxs-lookup"><span data-stu-id="722c3-155">Then, follow the references to the customer data using the shard keys stored in the index table.</span></span>

![Figura 6: Una tabla de índice que proporciona una búsqueda rápida para datos con particiones](./_images/index-table-figure-6.png)

## <a name="issues-and-considerations"></a><span data-ttu-id="722c3-157">Problemas y consideraciones</span><span class="sxs-lookup"><span data-stu-id="722c3-157">Issues and considerations</span></span>

<span data-ttu-id="722c3-158">Tenga en cuenta los puntos siguientes al decidir cómo implementar este patrón:</span><span class="sxs-lookup"><span data-stu-id="722c3-158">Consider the following points when deciding how to implement this pattern:</span></span>

- <span data-ttu-id="722c3-159">La sobrecarga que supone el mantenimiento de índices secundarios puede ser importante.</span><span class="sxs-lookup"><span data-stu-id="722c3-159">The overhead of maintaining secondary indexes can be significant.</span></span> <span data-ttu-id="722c3-160">Debe analizar y comprender las consultas que usa la aplicación.</span><span class="sxs-lookup"><span data-stu-id="722c3-160">You must analyze and understand the queries that your application uses.</span></span> <span data-ttu-id="722c3-161">Solo puede crear tablas de índice cuando es probable que se utilicen con frecuencia.</span><span class="sxs-lookup"><span data-stu-id="722c3-161">Only create index tables when they're likely to be used regularly.</span></span> <span data-ttu-id="722c3-162">No cree tablas de índice especulativas que admitan consultas que una aplicación no realiza, o que realiza solo de forma ocasional.</span><span class="sxs-lookup"><span data-stu-id="722c3-162">Don't create speculative index tables to support queries that an application doesn't perform, or performs only occasionally.</span></span>
- <span data-ttu-id="722c3-163">Duplicar datos en una tabla de índice puede agregar una sobrecarga significativa en los costos de almacenamiento y en el esfuerzo necesario para mantener varias copias de datos.</span><span class="sxs-lookup"><span data-stu-id="722c3-163">Duplicating data in an index table can add significant overhead in storage costs and the effort required to maintain multiple copies of data.</span></span>
- <span data-ttu-id="722c3-164">La implementación de una tabla de índice como una estructura normalizada que hace referencia a los datos originales necesita una aplicación para realizar dos operaciones de búsqueda para encontrar los datos.</span><span class="sxs-lookup"><span data-stu-id="722c3-164">Implementing an index table as a normalized structure that references the original data requires an application to perform two lookup operations to find data.</span></span> <span data-ttu-id="722c3-165">La primera operación busca la tabla de índice para recuperar la clave principal, y la segunda usa la clave principal para capturar los datos.</span><span class="sxs-lookup"><span data-stu-id="722c3-165">The first operation searches the index table to retrieve the primary key, and the second uses the primary key to fetch the data.</span></span>
- <span data-ttu-id="722c3-166">Si un sistema incorpora varias tablas de índice de conjuntos de datos muy grandes, puede que sea difícil mantener la coherencia entre las tablas de índice y los datos originales.</span><span class="sxs-lookup"><span data-stu-id="722c3-166">If a system incorporates a number of index tables over very large data sets, it can be difficult to maintain consistency between index tables and the original data.</span></span> <span data-ttu-id="722c3-167">Es posible diseñar la aplicación basándose en el modelo de coherencia final.</span><span class="sxs-lookup"><span data-stu-id="722c3-167">It might be possible to design the application around the eventual consistency model.</span></span> <span data-ttu-id="722c3-168">Por ejemplo, para insertar, actualizar o eliminar datos, una aplicación podría enviar un mensaje a una cola y permitir que una tarea independiente realice la operación y mantenga las tablas de índice que hacen referencia a estos datos de forma asincrónica.</span><span class="sxs-lookup"><span data-stu-id="722c3-168">For example, to insert, update, or delete data, an application could post a message to a queue and let a separate task perform the operation and maintain the index tables that reference this data asynchronously.</span></span> <span data-ttu-id="722c3-169">Para más información acerca de la implementación de la coherencia final, consulte [Data consistency primer](https://msdn.microsoft.com/library/dn589800.aspx)(Manual básico de coherencia de datos).</span><span class="sxs-lookup"><span data-stu-id="722c3-169">For more information about implementing eventual consistency, see the [Data Consistency Primer](https://msdn.microsoft.com/library/dn589800.aspx).</span></span>

   >  <span data-ttu-id="722c3-170">Las tablas de almacenamiento de Microsoft Azure admiten actualizaciones transaccionales de los cambios realizados en los datos contenidos en la misma partición (denominadas transacciones de grupos de entidades).</span><span class="sxs-lookup"><span data-stu-id="722c3-170">Microsoft Azure storage tables support transactional updates for changes made to data held in the same partition (referred to as entity group transactions).</span></span> <span data-ttu-id="722c3-171">Si puede almacenar los datos de una tabla de hechos y una o varias tablas de índice en la misma partición, puede utilizar esta característica para ayudar a garantizar la coherencia.</span><span class="sxs-lookup"><span data-stu-id="722c3-171">If you can store the data for a fact table and one or more index tables in the same partition, you can use this feature to help ensure consistency.</span></span>

- <span data-ttu-id="722c3-172">Las tablas de índice se pueden particionar por sí mismas.</span><span class="sxs-lookup"><span data-stu-id="722c3-172">Index tables might themselves be partitioned or sharded.</span></span>

## <a name="when-to-use-this-pattern"></a><span data-ttu-id="722c3-173">Cuándo usar este patrón</span><span class="sxs-lookup"><span data-stu-id="722c3-173">When to use this pattern</span></span>

<span data-ttu-id="722c3-174">Use este patrón para mejorar el rendimiento de las consultas si una aplicación necesita con frecuencia recuperar datos mediante una clave distinta de la clave (o partición) principal.</span><span class="sxs-lookup"><span data-stu-id="722c3-174">Use this pattern to improve query performance when an application frequently needs to retrieve data by using a key other than the primary (or shard) key.</span></span>

<span data-ttu-id="722c3-175">Este modelo podría no ser útil en las situaciones siguientes:</span><span class="sxs-lookup"><span data-stu-id="722c3-175">This pattern might not be useful when:</span></span>

- <span data-ttu-id="722c3-176">Los datos son volátiles.</span><span class="sxs-lookup"><span data-stu-id="722c3-176">Data is volatile.</span></span> <span data-ttu-id="722c3-177">Una tabla de índice puede quedar desactualizada muy rápidamente, lo cual hace que resulte ineficaz o que la sobrecarga que supone mantener la tabla de índice sea mayor que cualquier ahorro que se pueda conseguir mediante su uso.</span><span class="sxs-lookup"><span data-stu-id="722c3-177">An index table can become out of date very quickly, making it ineffective or making the overhead of maintaining the index table greater than any savings made by using it.</span></span>
- <span data-ttu-id="722c3-178">Un campo seleccionado como clave secundaria para una tabla de índice no discrimina y solo puede tener un pequeño conjunto de valores (por ejemplo, el género).</span><span class="sxs-lookup"><span data-stu-id="722c3-178">A field selected as the secondary key for an index table is nondiscriminating and can only have a small set of values (for example, gender).</span></span>
- <span data-ttu-id="722c3-179">El equilibrio de los valores de datos de un campo seleccionado como clave secundaria para una tabla de índice no está muy sesgado.</span><span class="sxs-lookup"><span data-stu-id="722c3-179">The balance of the data values for a field selected as the secondary key for an index table are highly skewed.</span></span> <span data-ttu-id="722c3-180">Por ejemplo, si el 90 % de los registros contienen el mismo valor en un campo, crear y mantener una tabla de índice para buscar datos basados en este campo puede que cree más sobrecarga que un examen de los datos de forma secuencial.</span><span class="sxs-lookup"><span data-stu-id="722c3-180">For example, if 90% of the records contain the same value in a field, then creating and maintaining an index table to look up data based on this field might create more overhead than scanning sequentially through the data.</span></span> <span data-ttu-id="722c3-181">Sin embargo, si las consultas se realizan con mucha frecuencia sobre valores que se encuentran en el 10 % restante, este índice podría resultar útil.</span><span class="sxs-lookup"><span data-stu-id="722c3-181">However, if queries very frequently target values that lie in the remaining 10%, this index can be useful.</span></span> <span data-ttu-id="722c3-182">Debe comprender las consultas que realiza la aplicación y con qué frecuencia las hace.</span><span class="sxs-lookup"><span data-stu-id="722c3-182">You should understand the queries that your application is performing, and how frequently they're performed.</span></span>

## <a name="example"></a><span data-ttu-id="722c3-183">Ejemplo</span><span class="sxs-lookup"><span data-stu-id="722c3-183">Example</span></span>

<span data-ttu-id="722c3-184">Las tablas de Azure Storage proporcionan un almacén de datos clave/valor, altamente escalable, para las aplicaciones que se ejecutan en la nube.</span><span class="sxs-lookup"><span data-stu-id="722c3-184">Azure storage tables provide a highly scalable key/value data store for applications running in the cloud.</span></span> <span data-ttu-id="722c3-185">Las aplicaciones almacenan y recuperan valores de datos especificando una clave.</span><span class="sxs-lookup"><span data-stu-id="722c3-185">Applications store and retrieve data values by specifying a key.</span></span> <span data-ttu-id="722c3-186">Los valores de datos pueden contener varios campos, pero la estructura de un elemento de datos es opaca para el almacenamiento de tablas, que simplemente controla un elemento de datos como una matriz de bytes.</span><span class="sxs-lookup"><span data-stu-id="722c3-186">The data values can contain multiple fields, but the structure of a data item is opaque to table storage, which simply handles a data item as an array of bytes.</span></span>

<span data-ttu-id="722c3-187">Las tablas de Azure Storage también admiten particionamiento.</span><span class="sxs-lookup"><span data-stu-id="722c3-187">Azure storage tables also support sharding.</span></span> <span data-ttu-id="722c3-188">La clave de particionamiento incluye dos elementos, una clave de partición y una clave de fila.</span><span class="sxs-lookup"><span data-stu-id="722c3-188">The sharding key includes two elements, a partition key and a row key.</span></span> <span data-ttu-id="722c3-189">Los elementos que tienen la misma clave de partición se almacenan en la misma partición y los elementos se almacenan por orden según la clave de fila dentro de una partición.</span><span class="sxs-lookup"><span data-stu-id="722c3-189">Items that have the same partition key are stored in the same partition (shard), and the items are stored in row key order within a shard.</span></span> <span data-ttu-id="722c3-190">El almacenamiento de tablas está optimizado para realizar consultas que capturan datos incluidos en un intervalo contiguo de valores de clave de fila que se encuentran dentro de una partición.</span><span class="sxs-lookup"><span data-stu-id="722c3-190">Table storage is optimized for performing queries that fetch data falling within a contiguous range of row key values within a partition.</span></span> <span data-ttu-id="722c3-191">Si va a compilar aplicaciones en la nube que almacenan información en tablas de Azure, debe estructurar los datos con esta característica en mente.</span><span class="sxs-lookup"><span data-stu-id="722c3-191">If you're building cloud applications that store information in Azure tables, you should structure your data with this feature in mind.</span></span>

<span data-ttu-id="722c3-192">Por ejemplo, piense en una aplicación que almacena información acerca de películas.</span><span class="sxs-lookup"><span data-stu-id="722c3-192">For example, consider an application that stores information about movies.</span></span> <span data-ttu-id="722c3-193">La aplicación realiza consultas frecuentes sobre películas por género (acción, documental, histórica, comedia, serie, etc).</span><span class="sxs-lookup"><span data-stu-id="722c3-193">The application frequently queries movies by genre (action, documentary, historical, comedy, drama, and so on).</span></span> <span data-ttu-id="722c3-194">Puede crear una tabla de Azure con particiones para cada género usando este como clave de partición y especificando el nombre de la película como la clave de fila, tal y como se indica en la siguiente ilustración.</span><span class="sxs-lookup"><span data-stu-id="722c3-194">You could create an Azure table with partitions for each genre by using the genre as the partition key, and specifying the movie name as the row key, as shown in the next figure.</span></span>

![Figura 7: Datos de la película almacenados en una tabla de Azure](./_images/index-table-figure-7.png)

<span data-ttu-id="722c3-196">Este enfoque es menos efectivo si la aplicación también necesita consultar películas por el actor principal.</span><span class="sxs-lookup"><span data-stu-id="722c3-196">This approach is less effective if the application also needs to query movies by starring actor.</span></span> <span data-ttu-id="722c3-197">En este caso, puede crear una tabla independiente de Azure que actúa como una tabla de índice.</span><span class="sxs-lookup"><span data-stu-id="722c3-197">In this case, you can create a separate Azure table that acts as an index table.</span></span> <span data-ttu-id="722c3-198">La clave de partición es el actor y la clave de fila es el nombre de la película.</span><span class="sxs-lookup"><span data-stu-id="722c3-198">The partition key is the actor and the row key is the movie name.</span></span> <span data-ttu-id="722c3-199">Los datos de cada actor se almacenan en particiones independientes.</span><span class="sxs-lookup"><span data-stu-id="722c3-199">The data for each actor will be stored in separate partitions.</span></span> <span data-ttu-id="722c3-200">Si una película tiene más de un protagonista, la misma película aparecerá en varias particiones.</span><span class="sxs-lookup"><span data-stu-id="722c3-200">If a movie stars more than one actor, the same movie will occur in multiple partitions.</span></span>

<span data-ttu-id="722c3-201">Puede duplicar los datos de la película en los valores mantenidos en cada partición mediante el primer enfoque descrito en la sección anterior de soluciones.</span><span class="sxs-lookup"><span data-stu-id="722c3-201">You can duplicate the movie data in the values held by each partition by adopting the first approach described in the Solution section above.</span></span> <span data-ttu-id="722c3-202">Sin embargo, es probable que cada película se replique varias veces (una vez por cada actor), por lo que podría resultar más eficaz desnormalizar parcialmente los datos para admitir las consultas más habituales (por ejemplo, los nombres de los otros actores) y habilitar una aplicación para recuperar los restantes detalles mediante la inclusión de la clave de partición necesaria para buscar la información completa en las particiones por género.</span><span class="sxs-lookup"><span data-stu-id="722c3-202">However, it's likely that each movie will be replicated several times (once for each actor), so it might be more efficient to partially denormalize the data to support the most common queries (such as the names of the other actors) and enable an application to retrieve any remaining details by including the partition key necessary to find the complete information in the genre partitions.</span></span> <span data-ttu-id="722c3-203">Este enfoque se describe en la tercera opción de la sección de soluciones.</span><span class="sxs-lookup"><span data-stu-id="722c3-203">This approach is described by the third option in the Solution section.</span></span> <span data-ttu-id="722c3-204">La ilustración siguiente muestra este enfoque.</span><span class="sxs-lookup"><span data-stu-id="722c3-204">The next figure shows this approach.</span></span>

![Figura 8: Las particiones por actor actúan como tablas de índice para los datos de las películas](./_images/index-table-figure-8.png)

## <a name="related-patterns-and-guidance"></a><span data-ttu-id="722c3-206">Orientación y patrones relacionados</span><span class="sxs-lookup"><span data-stu-id="722c3-206">Related patterns and guidance</span></span>

<span data-ttu-id="722c3-207">Los patrones y las directrices siguientes también pueden ser importantes a la hora de implementar este modelo:</span><span class="sxs-lookup"><span data-stu-id="722c3-207">The following patterns and guidance might also be relevant when implementing this pattern:</span></span>

- <span data-ttu-id="722c3-208">[Data Consistency Primer](https://msdn.microsoft.com/library/dn589800.aspx) (Manual básico de coherencia de datos).</span><span class="sxs-lookup"><span data-stu-id="722c3-208">[Data Consistency Primer](https://msdn.microsoft.com/library/dn589800.aspx).</span></span> <span data-ttu-id="722c3-209">Una tabla de índice se debe mantener a medida que cambian los datos que indexa.</span><span class="sxs-lookup"><span data-stu-id="722c3-209">An index table must be maintained as the data that it indexes changes.</span></span> <span data-ttu-id="722c3-210">En la nube, puede que no sea posible ni adecuado realizar operaciones que actualicen un índice como parte de la misma transacción que modifica los datos.</span><span class="sxs-lookup"><span data-stu-id="722c3-210">In the cloud, it might not be possible or appropriate to perform operations that update an index as part of the same transaction that modifies the data.</span></span> <span data-ttu-id="722c3-211">En ese caso, un enfoque con coherencia final es más adecuado.</span><span class="sxs-lookup"><span data-stu-id="722c3-211">In that case, an eventually consistent approach is more suitable.</span></span> <span data-ttu-id="722c3-212">Proporciona información sobre los problemas que pueden surgir con la coherencia final.</span><span class="sxs-lookup"><span data-stu-id="722c3-212">Provides information on the issues surrounding eventual consistency.</span></span>
- <span data-ttu-id="722c3-213">[Sharding pattern](./sharding.md) (Patrón de particionamiento).</span><span class="sxs-lookup"><span data-stu-id="722c3-213">[Sharding pattern](./sharding.md).</span></span> <span data-ttu-id="722c3-214">El patrón de tabla de índice se utiliza con frecuencia junto con datos con particiones mediante el uso de particiones.</span><span class="sxs-lookup"><span data-stu-id="722c3-214">The Index Table pattern is frequently used in conjunction with data partitioned by using shards.</span></span> <span data-ttu-id="722c3-215">El patrón Sharding proporciona más información acerca de cómo dividir un almacén de datos en un conjunto de particiones.</span><span class="sxs-lookup"><span data-stu-id="722c3-215">The Sharding pattern provides more information on how to divide a data store into a set of shards.</span></span>
- <span data-ttu-id="722c3-216">[Patrón Materialized View](./materialized-view.md).</span><span class="sxs-lookup"><span data-stu-id="722c3-216">[Materialized View pattern](./materialized-view.md).</span></span> <span data-ttu-id="722c3-217">En lugar de indexar los datos para admitir consultas que resuman los datos, puede ser más adecuado crear una vista materializada de estos.</span><span class="sxs-lookup"><span data-stu-id="722c3-217">Instead of indexing data to support queries that summarize data, it might be more appropriate to create a materialized view of the data.</span></span> <span data-ttu-id="722c3-218">Describe cómo admitir consultas de resumen eficaces mediante la generación de vistas rellenadas previamente con datos.</span><span class="sxs-lookup"><span data-stu-id="722c3-218">Describes how to support efficient summary queries by generating prepopulated views over data.</span></span>
