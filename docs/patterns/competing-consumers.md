---
title: Patrón de consumidores de la competencia
titleSuffix: Cloud Design Patterns
description: Permite que varios consumidores simultáneos procesen los mensajes recibidos en el mismo canal de mensajería.
keywords: Patrón de diseño
author: dragon119
ms.date: 06/23/2017
ms.custom: seodec18
ms.openlocfilehash: 77459ff42422969acdc83e66535197547d555de1
ms.sourcegitcommit: 1f4cdb08fe73b1956e164ad692f792f9f635b409
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 01/08/2019
ms.locfileid: "54112114"
---
# <a name="competing-consumers-pattern"></a><span data-ttu-id="60a1e-104">Patrón de consumidores de la competencia</span><span class="sxs-lookup"><span data-stu-id="60a1e-104">Competing Consumers pattern</span></span>

[!INCLUDE [header](../_includes/header.md)]

<span data-ttu-id="60a1e-105">Permite que varios consumidores simultáneos procesen los mensajes recibidos en el mismo canal de mensajería.</span><span class="sxs-lookup"><span data-stu-id="60a1e-105">Enable multiple concurrent consumers to process messages received on the same messaging channel.</span></span> <span data-ttu-id="60a1e-106">Este patrón permite que un sistema procese varios mensajes simultáneamente a fin de optimizar el rendimiento, mejorar la escalabilidad y disponibilidad, y equilibrar la carga de trabajo.</span><span class="sxs-lookup"><span data-stu-id="60a1e-106">This enables a system to process multiple messages concurrently to optimize throughput, to improve scalability and availability, and to balance the workload.</span></span>

## <a name="context-and-problem"></a><span data-ttu-id="60a1e-107">Contexto y problema</span><span class="sxs-lookup"><span data-stu-id="60a1e-107">Context and problem</span></span>

<span data-ttu-id="60a1e-108">Cabe esperar que una aplicación que se ejecuta en la nube administre un gran número de solicitudes.</span><span class="sxs-lookup"><span data-stu-id="60a1e-108">An application running in the cloud is expected to handle a large number of requests.</span></span> <span data-ttu-id="60a1e-109">En lugar de procesar cada solicitud de forma sincrónica, una técnica común es que la aplicación las pase mediante un sistema de mensajería a otro servicio (un servicio de consumidor) que las administra de manera asincrónica.</span><span class="sxs-lookup"><span data-stu-id="60a1e-109">Rather than process each request synchronously, a common technique is for the application to pass them through a messaging system to another service (a consumer service) that handles them asynchronously.</span></span> <span data-ttu-id="60a1e-110">Esta estrategia ayuda a garantizar que la lógica de negocios de la aplicación no se bloquee mientras se procesan las solicitudes.</span><span class="sxs-lookup"><span data-stu-id="60a1e-110">This strategy helps to ensure that the business logic in the application isn't blocked while the requests are being processed.</span></span>

<span data-ttu-id="60a1e-111">El número de solicitudes puede variar significativamente con el tiempo por diversos motivos.</span><span class="sxs-lookup"><span data-stu-id="60a1e-111">The number of requests can vary significantly over time for many reasons.</span></span> <span data-ttu-id="60a1e-112">Un aumento repentino de la actividad del usuario o solicitudes agregadas procedentes de varios inquilinos pueden provocar una carga de trabajo imprevisible.</span><span class="sxs-lookup"><span data-stu-id="60a1e-112">A sudden increase in user activity or aggregated requests coming from multiple tenants can cause an unpredictable workload.</span></span> <span data-ttu-id="60a1e-113">En horas de máxima actividad, un sistema podría tener la necesidad de procesar muchos cientos de solicitudes por segundo, mientras que en otras ocasiones el número puede ser muy pequeño.</span><span class="sxs-lookup"><span data-stu-id="60a1e-113">At peak hours a system might need to process many hundreds of requests per second, while at other times the number could be very small.</span></span> <span data-ttu-id="60a1e-114">Además, la naturaleza del trabajo realizado para administrar estas solicitudes puede ser muy variable.</span><span class="sxs-lookup"><span data-stu-id="60a1e-114">Additionally, the nature of the work performed to handle these requests might be highly variable.</span></span> <span data-ttu-id="60a1e-115">Usar una única instancia del servicio de consumidor puede provocar que la instancia se inunde de solicitudes, o el sistema de mensajería podría sobrecargarse por una afluencia de mensajes procedentes de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="60a1e-115">Using a single instance of the consumer service can cause that instance to become flooded with requests, or the messaging system might be overloaded by an influx of messages coming from the application.</span></span> <span data-ttu-id="60a1e-116">Para administrar esta carga de trabajo cambiante, el sistema puede ejecutar varias instancias del servicio de consumidor.</span><span class="sxs-lookup"><span data-stu-id="60a1e-116">To handle this fluctuating workload, the system can run multiple instances of the consumer service.</span></span> <span data-ttu-id="60a1e-117">Sin embargo, estos consumidores debe coordinarse para garantizar que cada mensaje se entrega solo a un único consumidor.</span><span class="sxs-lookup"><span data-stu-id="60a1e-117">However, these consumers must be coordinated to ensure that each message is only delivered to a single consumer.</span></span> <span data-ttu-id="60a1e-118">La carga de trabajo también debe equilibrarse entre los consumidores para impedir que una instancia se convierte en un cuello de botella.</span><span class="sxs-lookup"><span data-stu-id="60a1e-118">The workload also needs to be load balanced across consumers to prevent an instance from becoming a bottleneck.</span></span>

## <a name="solution"></a><span data-ttu-id="60a1e-119">Solución</span><span class="sxs-lookup"><span data-stu-id="60a1e-119">Solution</span></span>

<span data-ttu-id="60a1e-120">Use una cola de mensajes para implementar el canal de comunicación entre la aplicación y las instancias del servicio de consumidor.</span><span class="sxs-lookup"><span data-stu-id="60a1e-120">Use a message queue to implement the communication channel between the application and the instances of the consumer service.</span></span> <span data-ttu-id="60a1e-121">La aplicación publica las solicitudes en forma de mensajes en la cola, y las instancias de servicio de consumidor reciben los mensajes de la cola y los procesan.</span><span class="sxs-lookup"><span data-stu-id="60a1e-121">The application posts requests in the form of messages to the queue, and the consumer service instances receive messages from the queue and process them.</span></span> <span data-ttu-id="60a1e-122">Este enfoque permite que el mismo grupo de instancias de servicio de consumidor administren los mensajes desde cualquier instancia de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="60a1e-122">This approach enables the same pool of consumer service instances to handle messages from any instance of the application.</span></span> <span data-ttu-id="60a1e-123">En la ilustración se muestra cómo usar una cola de mensajes para distribuir trabajo a las instancias de un servicio.</span><span class="sxs-lookup"><span data-stu-id="60a1e-123">The figure illustrates using a message queue to distribute work to instances of a service.</span></span>

![Uso de una cola de mensajes para distribuir el trabajo a las instancias de un servicio](./_images/competing-consumers-diagram.png)

<span data-ttu-id="60a1e-125">Esta solución tiene las siguientes ventajas:</span><span class="sxs-lookup"><span data-stu-id="60a1e-125">This solution has the following benefits:</span></span>

- <span data-ttu-id="60a1e-126">Proporciona un sistema de redistribución de la carga que puede administrar grandes variaciones en el volumen de solicitudes enviadas por las instancias de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="60a1e-126">It provides a load-leveled system that can handle wide variations in the volume of requests sent by application instances.</span></span> <span data-ttu-id="60a1e-127">La cola actúa como búfer entre las instancias de la aplicación y las instancias de servicio de consumidor.</span><span class="sxs-lookup"><span data-stu-id="60a1e-127">The queue acts as a buffer between the application instances and the consumer service instances.</span></span> <span data-ttu-id="60a1e-128">Esto puede ayudar a reducir el impacto sobre la disponibilidad y la capacidad de respuesta de las instancias de aplicación y las de servicio, como se describe en [Queue-based Load Leveling pattern](./queue-based-load-leveling.md) (Patrón Queue-based Load Leveling).</span><span class="sxs-lookup"><span data-stu-id="60a1e-128">This can help to minimize the impact on availability and responsiveness for both the application and the service instances, as described by the [Queue-based Load Leveling pattern](./queue-based-load-leveling.md).</span></span> <span data-ttu-id="60a1e-129">Administrar un mensaje que requiere un procesamiento de ejecución prolongada no impide que otras instancias del servicio de consumidor administren simultáneamente otros mensajes.</span><span class="sxs-lookup"><span data-stu-id="60a1e-129">Handling a message that requires some long-running processing doesn't prevent other messages from being handled concurrently by other instances of the consumer service.</span></span>

- <span data-ttu-id="60a1e-130">Mejora la confiabilidad.</span><span class="sxs-lookup"><span data-stu-id="60a1e-130">It improves reliability.</span></span> <span data-ttu-id="60a1e-131">Si un productor se comunica directamente con un consumidor en lugar de usar este patrón, pero no supervisa el consumidor, existe una alta probabilidad de que los mensajes se pierdan o no puedan procesarse si se produce un error en el consumidor.</span><span class="sxs-lookup"><span data-stu-id="60a1e-131">If a producer communicates directly with a consumer instead of using this pattern, but doesn't monitor the consumer, there's a high probability that messages could be lost or fail to be processed if the consumer fails.</span></span> <span data-ttu-id="60a1e-132">En este patrón, no se envían mensajes a una instancia de servicio específica.</span><span class="sxs-lookup"><span data-stu-id="60a1e-132">In this pattern, messages aren't sent to a specific service instance.</span></span> <span data-ttu-id="60a1e-133">Una instancia de servicio que ha dado error no bloqueará a un productor y cualquier instancia de servicio de trabajo podrá procesar los mensajes.</span><span class="sxs-lookup"><span data-stu-id="60a1e-133">A failed service instance won't block a producer, and messages can be processed by any working service instance.</span></span>

- <span data-ttu-id="60a1e-134">No es necesaria una coordinación compleja entre los consumidores o entre el productor y las instancias de consumidor.</span><span class="sxs-lookup"><span data-stu-id="60a1e-134">It doesn't require complex coordination between the consumers, or between the producer and the consumer instances.</span></span> <span data-ttu-id="60a1e-135">La cola de mensajes garantiza que cada mensaje se entrega al menos una vez.</span><span class="sxs-lookup"><span data-stu-id="60a1e-135">The message queue ensures that each message is delivered at least once.</span></span>

- <span data-ttu-id="60a1e-136">Es escalable.</span><span class="sxs-lookup"><span data-stu-id="60a1e-136">It's scalable.</span></span> <span data-ttu-id="60a1e-137">El sistema puede aumentar o disminuir de forma dinámica el número de instancias del servicio de consumidor a medida que el volumen de mensajes varía.</span><span class="sxs-lookup"><span data-stu-id="60a1e-137">The system can dynamically increase or decrease the number of instances of the consumer service as the volume of messages fluctuates.</span></span>

- <span data-ttu-id="60a1e-138">Puede mejorar la resistencia si la cola de mensajes proporciona operaciones de lectura transaccionales.</span><span class="sxs-lookup"><span data-stu-id="60a1e-138">It can improve resiliency if the message queue provides transactional read operations.</span></span> <span data-ttu-id="60a1e-139">Si una instancia de servicio de consumidor lee y procesa el mensaje como parte de una operación transaccional y se produce un error en la instancia de servicio de consumidor, este patrón puede garantizar que el mensaje se devuelva a la cola para que otra instancia de servicio de consumidor pueda recogerlo y administrarlo.</span><span class="sxs-lookup"><span data-stu-id="60a1e-139">If a consumer service instance reads and processes the message as part of a transactional operation, and the consumer service instance fails, this pattern can ensure that the message will be returned to the queue to be picked up and handled by another instance of the consumer service.</span></span>

## <a name="issues-and-considerations"></a><span data-ttu-id="60a1e-140">Problemas y consideraciones</span><span class="sxs-lookup"><span data-stu-id="60a1e-140">Issues and considerations</span></span>

<span data-ttu-id="60a1e-141">Tenga en cuenta los puntos siguientes al decidir cómo implementar este patrón:</span><span class="sxs-lookup"><span data-stu-id="60a1e-141">Consider the following points when deciding how to implement this pattern:</span></span>

- <span data-ttu-id="60a1e-142">**Orden de los mensajes**.</span><span class="sxs-lookup"><span data-stu-id="60a1e-142">**Message ordering**.</span></span> <span data-ttu-id="60a1e-143">El orden en que las instancias de servicio de consumidor reciben loa mensajes no está garantizado y no refleja necesariamente el orden en que se crearon los mensajes.</span><span class="sxs-lookup"><span data-stu-id="60a1e-143">The order in which consumer service instances receive messages isn't guaranteed, and doesn't necessarily reflect the order in which the messages were created.</span></span> <span data-ttu-id="60a1e-144">Diseñe el sistema para asegurarse de que el procesamiento de mensajes sea idempotente, ya que de esta forma podrá eliminar cualquier dependencia en el orden en el que se administran los mensajes.</span><span class="sxs-lookup"><span data-stu-id="60a1e-144">Design the system to ensure that message processing is idempotent because this will help to eliminate any dependency on the order in which messages are handled.</span></span> <span data-ttu-id="60a1e-145">Para más información, consulte [Idempotency Patterns](https://blog.jonathanoliver.com/idempotency-patterns/) (Patrones de idempotencia) en el blog de Jonathon Oliver.</span><span class="sxs-lookup"><span data-stu-id="60a1e-145">For more information, see [Idempotency Patterns](https://blog.jonathanoliver.com/idempotency-patterns/) on Jonathon Oliver’s blog.</span></span>

    > <span data-ttu-id="60a1e-146">Las colas de Microsoft Azure Service Bus pueden implementar el orden de mensajes garantizado "primero en entrar, primero en salir" mediante sesiones de mensajes.</span><span class="sxs-lookup"><span data-stu-id="60a1e-146">Microsoft Azure Service Bus Queues can implement guaranteed first-in-first-out ordering of messages by using message sessions.</span></span> <span data-ttu-id="60a1e-147">Para más información, consulte [Sesiones de uso de patrones de mensajería](https://msdn.microsoft.com/magazine/jj863132.aspx).</span><span class="sxs-lookup"><span data-stu-id="60a1e-147">For more information, see [Messaging Patterns Using Sessions](https://msdn.microsoft.com/magazine/jj863132.aspx).</span></span>

- <span data-ttu-id="60a1e-148">**Diseño de servicios para proporcionar resistencia**.</span><span class="sxs-lookup"><span data-stu-id="60a1e-148">**Designing services for resiliency**.</span></span> <span data-ttu-id="60a1e-149">Si el sistema está diseñado para detectar y reiniciar las instancias de servicio con error, podría ser necesario implementar el procesamiento realizado por las instancias de servicio como operaciones idempotente a fin de reducir los efectos de que un único mensaje se recupere y procese más de una vez.</span><span class="sxs-lookup"><span data-stu-id="60a1e-149">If the system is designed to detect and restart failed service instances, it might be necessary to implement the processing performed by the service instances as idempotent operations to minimize the effects of a single message being retrieved and processed more than once.</span></span>

- <span data-ttu-id="60a1e-150">**Detección de mensajes dudosos**.</span><span class="sxs-lookup"><span data-stu-id="60a1e-150">**Detecting poison messages**.</span></span> <span data-ttu-id="60a1e-151">Un mensaje con formato incorrecto, o una tarea que requiere acceso a recursos que no están disponibles, puede hacer que una instancia de servicio produzca un error.</span><span class="sxs-lookup"><span data-stu-id="60a1e-151">A malformed message, or a task that requires access to resources that aren't available, can cause a service instance to fail.</span></span> <span data-ttu-id="60a1e-152">El sistema debe impedir que dichos mensajes se devuelvan a la cola y, en su lugar, capturar y almacenar los detalles de estos mensajes en otra parte, de modo que puedan analizarse si es necesario.</span><span class="sxs-lookup"><span data-stu-id="60a1e-152">The system should prevent such messages being returned to the queue, and instead capture and store the details of these messages elsewhere so that they can be analyzed if necessary.</span></span>

- <span data-ttu-id="60a1e-153">**Administración de resultados**.</span><span class="sxs-lookup"><span data-stu-id="60a1e-153">**Handling results**.</span></span> <span data-ttu-id="60a1e-154">La instancia de servicio que administra un mensaje se separa por completo de la lógica de aplicación que genera el mensaje, y es posible que no se puedan comunicar directamente.</span><span class="sxs-lookup"><span data-stu-id="60a1e-154">The service instance handling a message is fully decoupled from the application logic that generates the message, and they might not be able to communicate directly.</span></span> <span data-ttu-id="60a1e-155">Si la instancia de servicio genera resultados que deben pasarse de vuelta a la lógica de aplicación, esta información debe almacenarse en una ubicación que sea accesible para ambas.</span><span class="sxs-lookup"><span data-stu-id="60a1e-155">If the service instance generates results that must be passed back to the application logic, this information must be stored in a location that's accessible to both.</span></span> <span data-ttu-id="60a1e-156">Para evitar que la lógica de aplicación recupere datos incompletos, el sistema debe indicar cuándo el procesamiento ha finalizado.</span><span class="sxs-lookup"><span data-stu-id="60a1e-156">In order to prevent the application logic from retrieving incomplete data the system must indicate when processing is complete.</span></span>

     > <span data-ttu-id="60a1e-157">Si usa Azure, un proceso de trabajo puede pasar los resultados de vuelta a la lógica de aplicación mediante una cola de respuesta a mensajes dedicada.</span><span class="sxs-lookup"><span data-stu-id="60a1e-157">If you're using Azure, a worker process can pass results back to the application logic by using a dedicated message reply queue.</span></span> <span data-ttu-id="60a1e-158">La lógica de aplicación debe poder correlacionar estos resultados con el mensaje original.</span><span class="sxs-lookup"><span data-stu-id="60a1e-158">The application logic must be able to correlate these results with the original message.</span></span> <span data-ttu-id="60a1e-159">Este escenario se describe con más detalle en [Asynchronous Messaging Primer](https://msdn.microsoft.com/library/dn589781.aspx) (Manual básico de mensajería asincrónica).</span><span class="sxs-lookup"><span data-stu-id="60a1e-159">This scenario is described in more detail in the [Asynchronous Messaging Primer](https://msdn.microsoft.com/library/dn589781.aspx).</span></span>

- <span data-ttu-id="60a1e-160">**Escalado del sistema de mensajería**.</span><span class="sxs-lookup"><span data-stu-id="60a1e-160">**Scaling the messaging system**.</span></span> <span data-ttu-id="60a1e-161">En una solución a gran escala, una única cola de mensajes podría verse desbordada por el número de mensajes y convertirse en un cuello de botella en el sistema.</span><span class="sxs-lookup"><span data-stu-id="60a1e-161">In a large-scale solution, a single message queue could be overwhelmed by the number of messages and become a bottleneck in the system.</span></span> <span data-ttu-id="60a1e-162">En esta situación, considere la posibilidad de crear particiones del sistema de mensajería para enviar mensajes de productores específicos a una cola determinada o usar el equilibrio de carga para distribuir los mensajes entre varias colas de mensajes.</span><span class="sxs-lookup"><span data-stu-id="60a1e-162">In this situation, consider partitioning the messaging system to send messages from specific producers to a particular queue, or use load balancing to distribute messages across multiple message queues.</span></span>

- <span data-ttu-id="60a1e-163">**Garantía de confiabilidad del sistema de mensajería**.</span><span class="sxs-lookup"><span data-stu-id="60a1e-163">**Ensuring reliability of the messaging system**.</span></span> <span data-ttu-id="60a1e-164">Es necesario un sistema de mensajería confiable para garantizar que después de que la aplicación pone en cola un mensaje, este no se perderá.</span><span class="sxs-lookup"><span data-stu-id="60a1e-164">A reliable messaging system is needed to guarantee that after the application enqueues a message it won't be lost.</span></span> <span data-ttu-id="60a1e-165">Esto es esencial para garantizar que todos los mensajes se entregan al menos una vez.</span><span class="sxs-lookup"><span data-stu-id="60a1e-165">This is essential for ensuring that all messages are delivered at least once.</span></span>

## <a name="when-to-use-this-pattern"></a><span data-ttu-id="60a1e-166">Cuándo usar este patrón</span><span class="sxs-lookup"><span data-stu-id="60a1e-166">When to use this pattern</span></span>

<span data-ttu-id="60a1e-167">Use este patrón en los siguientes supuestos:</span><span class="sxs-lookup"><span data-stu-id="60a1e-167">Use this pattern when:</span></span>

- <span data-ttu-id="60a1e-168">La carga de trabajo de una aplicación se divida en tareas que se pueden ejecutar de forma asincrónica.</span><span class="sxs-lookup"><span data-stu-id="60a1e-168">The workload for an application is divided into tasks that can run asynchronously.</span></span>
- <span data-ttu-id="60a1e-169">Las tareas sean independientes y se puedan ejecutar en paralelo.</span><span class="sxs-lookup"><span data-stu-id="60a1e-169">Tasks are independent and can run in parallel.</span></span>
- <span data-ttu-id="60a1e-170">El volumen de trabajo sea tan variable que requiera una solución escalable.</span><span class="sxs-lookup"><span data-stu-id="60a1e-170">The volume of work is highly variable, requiring a scalable solution.</span></span>
- <span data-ttu-id="60a1e-171">La solución debe proporcionar alta disponibilidad y ser resistente si se produce un error en el procesamiento de una tarea.</span><span class="sxs-lookup"><span data-stu-id="60a1e-171">The solution must provide high availability, and must be resilient if the processing for a task fails.</span></span>

<span data-ttu-id="60a1e-172">Este modelo podría no ser útil en las situaciones siguientes:</span><span class="sxs-lookup"><span data-stu-id="60a1e-172">This pattern might not be useful when:</span></span>

- <span data-ttu-id="60a1e-173">No sea fácil dividir la carga de trabajo de la aplicación en tareas discretas, o haya un alto grado de dependencia entre las tareas.</span><span class="sxs-lookup"><span data-stu-id="60a1e-173">It's not easy to separate the application workload into discrete tasks, or there's a high degree of dependence between tasks.</span></span>
- <span data-ttu-id="60a1e-174">Las tareas deban realizarse de forma sincrónica y la lógica de la aplicación deba esperar a que una tarea se complete antes de continuar.</span><span class="sxs-lookup"><span data-stu-id="60a1e-174">Tasks must be performed synchronously, and the application logic must wait for a task to complete before continuing.</span></span>
- <span data-ttu-id="60a1e-175">Las tareas se deban realizar en una secuencia concreta.</span><span class="sxs-lookup"><span data-stu-id="60a1e-175">Tasks must be performed in a specific sequence.</span></span>

> <span data-ttu-id="60a1e-176">Algunos sistemas de mensajería admiten sesiones que permiten que un productor agrupe los mensajes y garantizan que el mismo consumidor los administre todos.</span><span class="sxs-lookup"><span data-stu-id="60a1e-176">Some messaging systems support sessions that enable a producer to group messages together and ensure that they're all handled by the same consumer.</span></span> <span data-ttu-id="60a1e-177">Este mecanismo se puede usar con los mensajes con prioridad (si se admiten) para implementar una forma de ordenación de los mensajes que los entrega en secuencia desde un productor hasta un único consumidor.</span><span class="sxs-lookup"><span data-stu-id="60a1e-177">This mechanism can be used with prioritized messages (if they are supported) to implement a form of message ordering that delivers messages in sequence from a producer to a single consumer.</span></span>

## <a name="example"></a><span data-ttu-id="60a1e-178">Ejemplo</span><span class="sxs-lookup"><span data-stu-id="60a1e-178">Example</span></span>

<span data-ttu-id="60a1e-179">Azure proporciona colas de almacenamiento y colas de Service Bus que pueden funcionar como un mecanismo para implementar este patrón.</span><span class="sxs-lookup"><span data-stu-id="60a1e-179">Azure provides storage queues and Service Bus queues that can act as a mechanism for implementing this pattern.</span></span> <span data-ttu-id="60a1e-180">La lógica de la aplicación puede publicar los mensajes en una cola, y los consumidores implementados como tareas en uno o varios roles pueden recuperar los mensajes de esta cola y procesarlos.</span><span class="sxs-lookup"><span data-stu-id="60a1e-180">The application logic can post messages to a queue, and consumers implemented as tasks in one or more roles can retrieve messages from this queue and process them.</span></span> <span data-ttu-id="60a1e-181">Para lograr resistencia, una cola de Service Bus permite que un consumidor use el modo `PeekLock` cuando recupera un mensaje de la cola.</span><span class="sxs-lookup"><span data-stu-id="60a1e-181">For resiliency, a Service Bus queue enables a consumer to use `PeekLock` mode when it retrieves a message from the queue.</span></span> <span data-ttu-id="60a1e-182">Este modo no quita realmente el mensaje, sino que simplemente lo oculta a otros consumidores.</span><span class="sxs-lookup"><span data-stu-id="60a1e-182">This mode doesn't actually remove the message, but simply hides it from other consumers.</span></span> <span data-ttu-id="60a1e-183">El consumidor original puede eliminar el mensaje cuando haya terminado de procesarlo.</span><span class="sxs-lookup"><span data-stu-id="60a1e-183">The original consumer can delete the message when it's finished processing it.</span></span> <span data-ttu-id="60a1e-184">Si se produce un error en el consumidor, el bloque de inspección agotará el tiempo de espera y el mensaje estará visible de nuevo, de forma que otro consumidor pueda recuperarlo.</span><span class="sxs-lookup"><span data-stu-id="60a1e-184">If the consumer fails, the peek lock will time out and the message will become visible again, allowing another consumer to retrieve it.</span></span>

<span data-ttu-id="60a1e-185">Para más información sobre el uso de colas de Azure Service Bus, consulte [Colas, temas y suscripciones de Service Bus](https://msdn.microsoft.com/library/windowsazure/hh367516.aspx).</span><span class="sxs-lookup"><span data-stu-id="60a1e-185">For detailed information on using Azure Service Bus queues, see [Service Bus queues, topics, and subscriptions](https://msdn.microsoft.com/library/windowsazure/hh367516.aspx).</span></span>

<span data-ttu-id="60a1e-186">Para más información sobre el uso de colas de almacenamiento de Azure, consulte [Introducción a Azure Queue Storage mediante .NET](/azure/storage/queues/storage-dotnet-how-to-use-queues).</span><span class="sxs-lookup"><span data-stu-id="60a1e-186">For information on using Azure storage queues, see [Get started with Azure Queue storage using .NET](/azure/storage/queues/storage-dotnet-how-to-use-queues).</span></span>

<span data-ttu-id="60a1e-187">El siguiente código de la clase `QueueManager` de la solución CompetingConsumers disponible en [GitHub](https://github.com/mspnp/cloud-design-patterns/tree/master/competing-consumers) muestra cómo puede crear una cola mediante una instancia `QueueClient` en el controlador de eventos `Start` en un rol web o de trabajo.</span><span class="sxs-lookup"><span data-stu-id="60a1e-187">The following code from the `QueueManager` class in CompetingConsumers solution available on [GitHub](https://github.com/mspnp/cloud-design-patterns/tree/master/competing-consumers) shows how you can create a queue by using a `QueueClient` instance in the `Start` event handler in a web or worker role.</span></span>

```csharp
private string queueName = ...;
private string connectionString = ...;
...

public async Task Start()
{
  // Check if the queue already exists.
  var manager = NamespaceManager.CreateFromConnectionString(this.connectionString);
  if (!manager.QueueExists(this.queueName))
  {
    var queueDescription = new QueueDescription(this.queueName);

    // Set the maximum delivery count for messages in the queue. A message
    // is automatically dead-lettered after this number of deliveries. The
    // default value for dead letter count is 10.
    queueDescription.MaxDeliveryCount = 3;

    await manager.CreateQueueAsync(queueDescription);
  }
  ...

  // Create the queue client. By default the PeekLock method is used.
  this.client = QueueClient.CreateFromConnectionString(
    this.connectionString, this.queueName);
}
```

<span data-ttu-id="60a1e-188">El fragmento de código siguiente muestra cómo una aplicación puede crear y enviar un lote de mensajes a la cola.</span><span class="sxs-lookup"><span data-stu-id="60a1e-188">The next code snippet shows how an application can create and send a batch of messages to the queue.</span></span>

```csharp
public async Task SendMessagesAsync()
{
  // Simulate sending a batch of messages to the queue.
  var messages = new List<BrokeredMessage>();

  for (int i = 0; i < 10; i++)
  {
    var message = new BrokeredMessage() { MessageId = Guid.NewGuid().ToString() };
    messages.Add(message);
  }
  await this.client.SendBatchAsync(messages);
}
```

<span data-ttu-id="60a1e-189">El código siguiente muestra cómo una instancia de servicio de consumidor puede recibir mensajes de la cola siguiendo un enfoque orientado a eventos.</span><span class="sxs-lookup"><span data-stu-id="60a1e-189">The following code shows how a consumer service instance can receive messages from the queue by following an event-driven approach.</span></span> <span data-ttu-id="60a1e-190">El parámetro `processMessageTask` para el método `ReceiveMessages` es un delegado que hace referencia al código que se ejecuta cuando se recibe un mensaje.</span><span class="sxs-lookup"><span data-stu-id="60a1e-190">The `processMessageTask` parameter to the `ReceiveMessages` method is a delegate that references the code to run when a message is received.</span></span> <span data-ttu-id="60a1e-191">Este código se ejecuta de forma asincrónica.</span><span class="sxs-lookup"><span data-stu-id="60a1e-191">This code is run asynchronously.</span></span>

```csharp
private ManualResetEvent pauseProcessingEvent;
...

public void ReceiveMessages(Func<BrokeredMessage, Task> processMessageTask)
{
  // Set up the options for the message pump.
  var options = new OnMessageOptions();

  // When AutoComplete is disabled it's necessary to manually
  // complete or abandon the messages and handle any errors.
  options.AutoComplete = false;
  options.MaxConcurrentCalls = 10;
  options.ExceptionReceived += this.OptionsOnExceptionReceived;

  // Use of the Service Bus OnMessage message pump.
  // The OnMessage method must be called once, otherwise an exception will occur.
  this.client.OnMessageAsync(
    async (msg) =>
    {
      // Will block the current thread if Stop is called.
      this.pauseProcessingEvent.WaitOne();

      // Execute processing task here.
      await processMessageTask(msg);
    },
    options);
}
...

private void OptionsOnExceptionReceived(object sender,
  ExceptionReceivedEventArgs exceptionReceivedEventArgs)
{
  ...
}
```

<span data-ttu-id="60a1e-192">Tenga en cuenta que las características de escalado automática, como los que están disponibles en Azure, pueden utilizarse para iniciar y detener instancias de rol a medida que varía la longitud de cola.</span><span class="sxs-lookup"><span data-stu-id="60a1e-192">Note that autoscaling features, such as those available in Azure, can be used to start and stop role instances as the queue length fluctuates.</span></span> <span data-ttu-id="60a1e-193">Para más información, consulte [Guía de escalado automático](https://msdn.microsoft.com/library/dn589774.aspx).</span><span class="sxs-lookup"><span data-stu-id="60a1e-193">For more information, see [Autoscaling Guidance](https://msdn.microsoft.com/library/dn589774.aspx).</span></span> <span data-ttu-id="60a1e-194">Además, no es necesario mantener una correspondencia uno a uno entre las instancias de rol y los procesos de trabajo&mdash;una única instancia de rol puede implementar varios procesos de trabajo.</span><span class="sxs-lookup"><span data-stu-id="60a1e-194">Also, it's not necessary to maintain a one-to-one correspondence between role instances and worker processes&mdash;a single role instance can implement multiple worker processes.</span></span> <span data-ttu-id="60a1e-195">Para más información, consulte [Compute Resource Consolidation pattern](./compute-resource-consolidation.md) (Patrón Compute Resource Consolidation).</span><span class="sxs-lookup"><span data-stu-id="60a1e-195">For more information, see [Compute Resource Consolidation pattern](./compute-resource-consolidation.md).</span></span>

## <a name="related-patterns-and-guidance"></a><span data-ttu-id="60a1e-196">Orientación y patrones relacionados</span><span class="sxs-lookup"><span data-stu-id="60a1e-196">Related patterns and guidance</span></span>

<span data-ttu-id="60a1e-197">Los patrones y las directrices siguientes podrían ser importantes a la hora de implementar este patrón:</span><span class="sxs-lookup"><span data-stu-id="60a1e-197">The following patterns and guidance might be relevant when implementing this pattern:</span></span>

- <span data-ttu-id="60a1e-198">[Manual de mensajería asincrónica](https://msdn.microsoft.com/library/dn589781.aspx).</span><span class="sxs-lookup"><span data-stu-id="60a1e-198">[Asynchronous Messaging Primer](https://msdn.microsoft.com/library/dn589781.aspx).</span></span> <span data-ttu-id="60a1e-199">Las colas de mensajes son un mecanismo de comunicaciones asincrónico.</span><span class="sxs-lookup"><span data-stu-id="60a1e-199">Message queues are an asynchronous communications mechanism.</span></span> <span data-ttu-id="60a1e-200">Si un servicio de consumidor debe enviar una respuesta a una aplicación, podría ser necesario implementar alguna forma de mensajería de respuesta.</span><span class="sxs-lookup"><span data-stu-id="60a1e-200">If a consumer service needs to send a reply to an application, it might be necessary to implement some form of response messaging.</span></span> <span data-ttu-id="60a1e-201">En Asynchronous Messaging Primer se proporciona información sobre cómo implementar la mensajería de solicitud/respuesta con colas de mensajes.</span><span class="sxs-lookup"><span data-stu-id="60a1e-201">The Asynchronous Messaging Primer provides information on how to implement request/reply messaging using message queues.</span></span>

- <span data-ttu-id="60a1e-202">[Guía de escalado automático](https://msdn.microsoft.com/library/dn589774.aspx).</span><span class="sxs-lookup"><span data-stu-id="60a1e-202">[Autoscaling Guidance](https://msdn.microsoft.com/library/dn589774.aspx).</span></span> <span data-ttu-id="60a1e-203">Se podrían iniciar y detener instancias de un servicio de consumidor dado que la longitud de la cola en la que las aplicaciones publican los mensajes varía.</span><span class="sxs-lookup"><span data-stu-id="60a1e-203">It might be possible to start and stop instances of a consumer service since the length of the queue applications post messages on varies.</span></span> <span data-ttu-id="60a1e-204">El escalado automático puede ayudar a mantener el rendimiento durante los períodos de procesamiento de máximo.</span><span class="sxs-lookup"><span data-stu-id="60a1e-204">Autoscaling can help to maintain throughput during times of peak processing.</span></span>

- <span data-ttu-id="60a1e-205">[Patrón Compute Resource Consolidation](./compute-resource-consolidation.md).</span><span class="sxs-lookup"><span data-stu-id="60a1e-205">[Compute Resource Consolidation pattern](./compute-resource-consolidation.md).</span></span> <span data-ttu-id="60a1e-206">Se podrían consolidar varias instancias de un servicio de consumidor en un único proceso para reducir los costes y la sobrecarga de administración.</span><span class="sxs-lookup"><span data-stu-id="60a1e-206">It might be possible to consolidate multiple instances of a consumer service into a single process to reduce costs and management overhead.</span></span> <span data-ttu-id="60a1e-207">El patrón de consolidación de los recursos de proceso describe las ventajas e inconvenientes de este enfoque.</span><span class="sxs-lookup"><span data-stu-id="60a1e-207">The Compute Resource Consolidation pattern describes the benefits and tradeoffs of following this approach.</span></span>

- <span data-ttu-id="60a1e-208">[Patrón Queue-Based Load Leveling](./queue-based-load-leveling.md).</span><span class="sxs-lookup"><span data-stu-id="60a1e-208">[Queue-based Load Leveling pattern](./queue-based-load-leveling.md).</span></span> <span data-ttu-id="60a1e-209">La introducción de una cola de mensajes puede agregar resistencia al sistema, al permitir que las instancias de servicio administren volúmenes muy diversos de solicitudes desde instancias de aplicación.</span><span class="sxs-lookup"><span data-stu-id="60a1e-209">Introducing a message queue can add resiliency to the system, enabling service instances to handle widely varying volumes of requests from application instances.</span></span> <span data-ttu-id="60a1e-210">La cola de mensajes actúa como búfer, que redistribuye la carga.</span><span class="sxs-lookup"><span data-stu-id="60a1e-210">The message queue acts as a buffer, which levels the load.</span></span> <span data-ttu-id="60a1e-211">El patrón de redistribución de carga basada en colas describe este escenario con mayor detalle.</span><span class="sxs-lookup"><span data-stu-id="60a1e-211">The Queue-based Load Leveling pattern describes this scenario in more detail.</span></span>

- <span data-ttu-id="60a1e-212">Este patrón lleva asociada una [aplicación de ejemplo](https://github.com/mspnp/cloud-design-patterns/tree/master/competing-consumers).</span><span class="sxs-lookup"><span data-stu-id="60a1e-212">This pattern has a [sample application](https://github.com/mspnp/cloud-design-patterns/tree/master/competing-consumers) associated with it.</span></span>
